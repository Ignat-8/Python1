# Осуществить программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс «Клетка». В его
# конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число). В классе должны быть
# реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение
# (__mul__()), деление (__floordiv____truediv__()). Эти методы должны применяться только к клеткам и выполнять
# увеличение, уменьшение, умножение и округление до целого числа деления клеток соответственно. Сложение. Объединение
# двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток. Вычитание. Участвуют
# две клетки. Операцию необходимо выполнять, только если разность количества ячеек двух клеток больше нуля, иначе
# выводить соответствующее сообщение. Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки — произведение
# количества ячеек этих двух клеток. Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как
# целочисленное деление количества ячеек этих двух клеток. В классе необходимо реализовать метод make_order(),
# принимающий экземпляр класса и количество ячеек в ряду. Этот метод позволяет организовать ячейки по рядам. Метод должен
# возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек
# на формирование ряда не хватает, то в последний ряд записываются все оставшиеся. Например, количество ячеек клетки
# равняется 12, а количество ячеек в ряду — 5. В этом случае метод make_order() вернёт строку: *****\n*****\n**. Или
# количество ячеек клетки — 15, а количество ячеек в ряду равняется 5. Тогда метод make_order() вернёт строку:
# *****\n*****\n*****.

class Cell:
    def __init__(self, num_cells):
        if num_cells > 0:
            self.num_cells = int(num_cells)
        else:
            print(f'Ячейка не может быть нулевой или отрицательной')
            raise ValueError

    def __len__(self):
        return self.num_cells

    def make_order(self, row_length):
        str_return = ''
        str_length = len(self)
        for i in range(str_length):
            str_return += '*'
            if (i + 1) // row_length and not (i + 1) % row_length and (i + 1) != str_length:
                str_return += '\n'
        return str_return

    def __str__(self):
        return f'*' * self.num_cells

    def __add__(self, other):
        return f'*' * (self.num_cells + other.num_cells)

    def __sub__(self, other):
        if (self.num_cells - other.num_cells) >= 0:
            return f'*' * (self.num_cells - other.num_cells)
        else:
            return f'Ошибка - уменьшаемая ячейка меньше вычитаемой'

    def __mul__(self, other):
        return f'*' * (self.num_cells * other.num_cells)

    def __truediv__(self, other):
        return f'*' * (self.num_cells // other.num_cells)


C_1 = Cell(7)
C_2 = Cell(3)
C_3 = Cell(9)
print(f'Ячейка 1 : длина {len(C_1)}\n{C_1}')
print(f'Ячейка 2 : длина {len(C_2)}\n{C_2}')
print(f'Ячейка 3 : длина {len(C_3)}\n{C_3}')
print(f'Сумма ячеек 1 + 2 : длина {len(C_1) + len(C_2)}\n{C_1 + C_2}')
print(f'Разность ячеек 1 - 2 : длина {len(C_1) - len(C_2)}\n{C_1 - C_2}')
print(f'Разность ячеек 1 - 3 : длина {len(C_1) - len(C_3)}\n{C_1 - C_3}')
print(f'Умножение ячеек 1 * 2 : длина {len(C_1) * len(C_2)}\n{C_1 * C_2}')
print(f'Деление ячеек 1 / 2 : длина {len(C_1) // len(C_2)}\n{C_1 / C_2}')
row_length = 7
print(f'Отформатированная ячейка 3 по основанию {row_length}\n{C_3.make_order(row_length)}')
row_length = 10
print(f'Отформатированное умножение ячеек 1 и 2 по основанию {row_length}\n{Cell(len(C_1) * len(C_2)).make_order(row_length)}')
